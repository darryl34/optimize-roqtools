#! /usr/bin/env python
# *************************************************************************************
# Hpspice regulator model generator (UI backend)
# Script version: 1.0
# Python version: Python 3.6.5
# Compatible OS: Windows 10
# Requirements: Tkinter, pyperclip, Hpspice, lib_digital_ic(v1.0)
# Developer (v1.0): Corena Tong (listong)
# Notes:
#     This is a script provides backend compute functionality for the UI created by
#    'regulator_gui.py'.
#   Command: python3 regulator_gui.py
# Version doc:
#  * First version
# *************************************************************************************
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 7.4
#  in conjunction with Tcl version 8.6
#    Jun 14, 2022 08:46:23 AM CST  platform: Windows NT

import sys
import os
import re
import pyperclip as pc
import tkinter as tk
import tkinter.ttk as ttk
import subprocess
import digital_ic_gui
import lib_digital_ic

# Global members
PIN_LIST = []
pin_count = 0

def main(*args):
    '''Main entry point for the application.'''
    global root
    root = tk.Tk()
    root.protocol( 'WM_DELETE_WINDOW' , root.destroy)
    # Creates a toplevel widget.
    global _top1, _w1
    _top1 = root
    _w1 = digital_ic_gui.Toplevel1(_top1)
    root.mainloop()

def copyBtnClicked(*args):
    print('digital_ic_support.copyBtnClicked')
    # Copy the content inside the result box, to be update
    pc.copy(_w1.Scrolledtext1.get("1.0", tk.END))
    sys.stdout.flush()


def submitLvdsBtnClicked(*args):
    print('digital_ic_support.submitLvdsBtnClicked')
    sys.stdout.flush()

    # Generate model
    # Generate 1 ohm resistor network for similar pins
    shorts = lib_digital_ic.short_similar_pins(pin_list=PIN_LIST, resistance="1")
    
    # Generate model
    print("[INFO] Generating model ...", flush=True)
    reg_model = lib_digital_ic.main_gen_lvds_model(pin_list=PIN_LIST, pGND=_w1.gndPinNum.get(), pVCC=_w1.vccPinNum.get(),
                    pVEE=_w1.veePinNum.get(), res_shorts=shorts, kpn=_w1.kpn.get())

    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.insert(tk.INSERT, reg_model)
    _w1.Scrolledtext1.configure(state='disabled')
    print("[INFO] Generating model ... done", flush=True)

    # write to file
    with open('{}.inc'.format(_w1.kpn.get()), 'w') as f:
        f.write(reg_model)

    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.insert(tk.INSERT, "\n\n*******************************************************************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "********************END OF MODEL BEGIN HARNESS *********************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "*******************************************************************\n\n")
    _w1.Scrolledtext1.configure(state='disabled')

    # Generate harness
    print("[INFO] Generating harness ...", flush=True)
    reg_harness = lib_digital_ic.gen_lvds_harness(kpn=_w1.kpn.get(), pin_list=PIN_LIST, vcc=_w1.vcc.get(), vPos=_w1.vpos.get(), vNeg=_w1.vneg.get())
    
    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.insert(tk.INSERT, reg_harness)
    _w1.Scrolledtext1.configure(state='disabled')

    # Open harness.cki file and write reg_harness into ds.cki
    with open("fixture.cki", "w") as f:
        f.write(reg_harness)
    print("[INFO] Generating harness ... done", flush=True)
    
    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.insert(tk.INSERT, "\n\n*******************************************************************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "********************END OF HARNESS BEGIN CMD *********************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "*******************************************************************\n\n")
    _w1.Scrolledtext1.configure(state='disabled')

    # Generate core.cmd
    print("[INFO] Generating core.cmd..", flush=True)
    reg_core_cmd = lib_digital_ic.gen_lvds_cmd()
    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.insert(tk.INSERT, reg_core_cmd)
    _w1.Scrolledtext1.configure(state='disabled')
    # create core.cmd and write reg_core_cmd into cmd
    with open("core.cmd", "w") as f:
        f.write(reg_core_cmd)
    print("[INFO] Generating core.cmd ... done", flush=True)
    
    # TODO: Perform optimization
    # Execute . cmd_ds
    subprocess.call(["hpspice","-s","-c","'.","core.cmd'"])
    
    #print("[INFO] Generating stress.cmd ... done", flush=True)
    print("[INFO] LVDS modelling completed", flush=True)


def submitEclBtnClicked(*args):
    print('digital_ic_support.submitEclBtnClicked')
    sys.stdout.flush()

    # Generate model
    # Generate 1 ohm resistor network for similar pins
    shorts = lib_digital_ic.short_similar_pins(pin_list=PIN_LIST, resistance="1")
    # Generate model
    print("[INFO] Generating model ...", flush=True)
    
    # Generating model based on user's inputs
    reg_model = lib_digital_ic.main_gen_ecl_model(pin_list=PIN_LIST, pGND=_w1.gndPinNum.get(),
                                                  pVCC=_w1.vccPinNum.get(), pVEE=_w1.veePinNum.get(),
                                                  res_shorts=shorts, kpn=_w1.kpn.get())

    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.insert(tk.INSERT, reg_model)
    _w1.Scrolledtext1.configure(state='disabled')
    print("[INFO] Generating model ... done", flush=True)

    # Create new .inc file
    with open("{}.inc".format(_w1.kpn.get()), "w") as f:
        f.write(reg_model)

    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.insert(tk.INSERT, "\n\n*******************************************************************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "********************END OF MODEL BEGIN HARNESS *********************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "*******************************************************************\n\n")
    _w1.Scrolledtext1.configure(state='disabled')

    # Generate harness
    print("[INFO] Generating harness ...", flush=True)
    reg_harness = ""
    reg_harness, numQ = lib_digital_ic.gen_ecl_harness(kpn=_w1.kpn.get(), pin_list=PIN_LIST, vcc=_w1.vcc.get(), vee=_w1.vee.get(), vtt=_w1.vtt.get())
    
    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.insert(tk.INSERT, reg_harness)
    _w1.Scrolledtext1.configure(state='disabled')

    # Open harness.cki file and write reg_harness into ds.cki
    with open("fixture.cki", "w") as f:
        f.write(reg_harness)
    print("[INFO] Generating harness ... done", flush=True)
    
    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.insert(tk.INSERT, "\n\n*******************************************************************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "********************END OF HARNESS BEGIN CMD *********************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "*******************************************************************\n\n")
    _w1.Scrolledtext1.configure(state='disabled')

    # Generate core.cmd
    print("[INFO] Generating core.cmd..", flush=True)
    reg_core_cmd = ""
    reg_core_cmd = lib_digital_ic.gen_ecl_cmd(numQ)
    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.insert(tk.INSERT, reg_core_cmd)
    _w1.Scrolledtext1.configure(state='disabled')
    # create core.cmd and write reg_core_cmd into cmd
    with open("core.cmd", "w") as f:
        f.write(reg_core_cmd)
    print("[INFO] Generating core.cmd ... done", flush=True)
    
    # Execute . core.cmd
    subprocess.call(["hpspice","-s","-c","'.","core.cmd'"])

    #print("[INFO] Generating stress.cmd ... done", flush=True)
    print("[INFO] ECL modelling completed", flush=True)
    

def createCmlBtnClicked(*args):
    print('digital_ic_support.createCmlBtnClicked')
    sys.stdout.flush()

    # Clear existing output
    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.delete("1.0", tk.END)
    _w1.Scrolledtext1.configure(state='disabled')

    # Check for user's input on model settings and generate for harness and cmd
    global _top4, _w4
    _top4 = tk.Toplevel(root)
    _w4 = digital_ic_gui.Toplevel4(_top4)

def fillCmlBtnClicked(*args):  
    print('digital_ic_support.fillEclBtnClicked')
    sys.stdout.flush()

    _w4.rPD.set("38")
    _w4.rPDCurrent.set("90m")
    _w4.rPDVoltage.set("2.5")
    _w4.dVoltage.set("0.5")
    _w4.dCurrent.set("40m")
    _w4.dN.set("1")
    _w4.dIS.set("33n")
    _w4.dRS.set("3.5")

def submitCmlBtnClicked(*args):
    print('digital_ic_support.submitCmlBtnClicked')
    for arg in args:
        print ('another arg:', arg)
    sys.stdout.flush()

    # Generate model
    # Generate 1 ohm resistor network for similar pins
    shorts = lib_digital_ic.short_similar_pins(pin_list=PIN_LIST, resistance="1")
    # Generate model
    print("[INFO] Generating model ...", flush=True)
    reg_model = ""
    
    # Generating model based on user's inputs
    reg_model += lib_digital_ic.main_gen_cml_model(pin_list=PIN_LIST, pGND=_w1.gndPinNum.get(),
                                                   pVCC=_w1.vccPinNum.get(), pVEE=_w1.veePinNum.get(),
                                                   res_shorts=shorts,kpn=_w1.kpn.get()) 

    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.insert(tk.INSERT, reg_model)
    _w1.Scrolledtext1.configure(state='disabled')
    print("[INFO] Generating model ... done", flush=True)

    # Create new .inc file
    with open('{}.inc'.format(_w1.kpn.get()), 'w') as f:
        f.write(reg_model)

    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.insert(tk.INSERT, "\n\n*******************************************************************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "********************END OF MODEL BEGIN HARNESS *********************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "*******************************************************************\n\n")
    _w1.Scrolledtext1.configure(state='disabled')

    # Generate harness
    print("[INFO] Generating harness ...", flush=True)
    reg_harness = ""
    reg_harness = lib_digital_ic.gen_cml_harness(kpn=_w1.kpn.get(), pin_list=PIN_LIST, vcc=_w1.vcc.get(), vee=_w1.vee.get(), vin=_w1.vpos.get())
    
    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.insert(tk.INSERT, reg_harness)
    _w1.Scrolledtext1.configure(state='disabled')

    # Open harness.cki file and write reg_harness into ds.cki
    wf = open("fixture.cki", "w")
    wf.write(reg_harness)
    wf.close()
    print("[INFO] Generating harness ... done", flush=True)
    
    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.insert(tk.INSERT, "\n\n*******************************************************************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "********************END OF HARNESS BEGIN CMD *********************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "*******************************************************************\n\n")
    _w1.Scrolledtext1.configure(state='disabled')

    # Generate core.cmd
    print("[INFO] Generating core.cmd..", flush=True)
    reg_core_cmd = ""
    reg_core_cmd = lib_digital_ic.gen_cml_cmd()
    
    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.insert(tk.INSERT, reg_core_cmd)
    _w1.Scrolledtext1.configure(state='disabled')
    
    # create core.cmd and write reg_core_cmd into cmd
    wf = open("core.cmd", "w")
    wf.write(reg_core_cmd)
    wf.close()
    print("[INFO] Generating core.cmd ... done", flush=True)
    
    # Execute . core.cmd
    subprocess.call(["hpspice","-s","-c","'.","core.cmd'"])

    #print("[INFO] Generating cmd_eff ... done", flush=True)
    print("[INFO] CML modelling completed", flush=True)
    

def loadPinBtnClicked(*args):
    print('digital_ic_support.loadPinBtnClicked')
    '''
    Method to load pin information from textbox(UI).
    '''
    try:
        # Check if the list is filled or empty
        pininfo = _w1.pinInfoText.get("1.0","end-1c")
        if pininfo:
            global PIN_LIST, pin_count, search_list, ser_pin_list
            #pininfo = _w1.pinInfoText.get("1.0","end-1c")
            pininfo = pininfo.splitlines()
            pin = []
            for x in pininfo:
                temp = x.split()
                if temp[1].isnumeric() or "%" in temp[1]:
                    pin.append([temp[1],temp[2]])
                    pin_count = pin_count + 1
            PIN_LIST[:] = list(pin)
            
            # Rename pins with same name
            pin_names=[item[1] for item in PIN_LIST]
            pin_numbs=[item[0] for item in PIN_LIST]
            p_lst_dups = set()
            PIN_LIST = []
            for i in range(0, pin_count):
                count = pin_names.count(pin_names[i])
                if count > 1:
                    p_lst_dups.add(pin_names[i])
                    pin_names[i] = pin_names[i]+"_"+str(count)
                elif pin_names[i] in p_lst_dups:
                    pin_names[i] = pin_names[i]+"_1"
                PIN_LIST.append([pin_numbs[i], pin_names[i]])
                pin_names[i] = ''
                pin_numbs[i] = ''
            # PIN_LIST.reverse()

            search_list = PIN_LIST
            ser_pin_list = list(range(0,len(search_list)))
            updatePinList()
            clrList()
            _w1.pinNum.set('''Number of Pins : '''+str(pin_count)) 

            # Attempt to auto detect pins
            # Reset entry boxes
            _w1.gndPinNum.set("")
            _w1.vccPinNum.set("")
            _w1.veePinNum.set("")
            _w1.vbbPinNum.set("")
            _w1.inselPinNum.set("")
            _w1.refPinNum.set("")
            _w1.vtrPinNum.set("")
            for pin in PIN_LIST:
                if not _w1.vccPinNum.get() and "vcc" in pin[1].lower():
                    _w1.vccPinNum.set(pin[0])
                elif not _w1.gndPinNum.get() and "gnd" in pin[1].lower():
                    _w1.gndPinNum.set(pin[0])
                elif not _w1.veePinNum.get() and "vee" in pin[1].lower():
                    _w1.veePinNum.set(pin[0])
                elif not _w1.inselPinNum.get() and "in_sel" in pin[1].lower():
                    _w1.inselPinNum.set(pin[0])
                elif not _w1.refPinNum.get() and "ref" in pin[1].lower():
                    _w1.refPinNum.set(pin[0])
                elif not _w1.vbbPinNum.get() and "vbb" in pin[1].lower():
                    _w1.vbbPinNum.set(pin[0])
                elif not _w1.vtrPinNum.get() and "vt" in pin[1].lower():
                    _w1.vtrPinNum.set(pin[0])

        else:
            tk.messagebox.showerror("Input Error", "Either Input Pin Information is empty or first line in the box is empty.")
            
    except Exception as e:
        print("Error in assigning: ",e)

    sys.stdout.flush()
    pin_count = 0
            

def updatePinList():
    '''
    Method to load given list into Listbox.
    '''
    try:
        _w1.Listbox1.delete(0,'end')
        for i in range(len(PIN_LIST)):
            _w1.Listbox1.insert(i+1, ' '.join(PIN_LIST[i]))
    except Exception as e:
        print("Error in updating Listbox: ",e)

def clrList():
    '''
    Method to clear all selection in list.
    '''
    global sel_pin_list
    _w1.Listbox1.selection_clear(0, tk.END)
    sel_pin_list = []


def resetBtnClicked(*args):
    print('digital_ic_support.resetBtnClicked')
    clearPinInfo()
    clearScrollText()
    sys.stdout.flush()

def clearPinInfo():
    _w1.vccPinEntry.delete(0, tk.END)
    _w1.gndPinEntry.delete(0, tk.END)
    _w1.veePinEntry.delete(0, tk.END)
    _w1.vbbPinEntry.delete(0, tk.END)
    _w1.inselPinEntry.delete(0, tk.END)
    _w1.refPinEntry.delete(0, tk.END)
    _w1.vtrPinEntry.delete(0, tk.END)
    _w1.kpn.set('')
    _w1.vcc.set('')
    _w1.vpos.set('')
    _w1.vneg.set('')
    _w1.vee.set('')
    _w1.vtt.set('')

def clearScrollText():
    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.delete("1.0", tk.END)
    _w1.Scrolledtext1.configure(state='disabled')

if __name__ == '__main__':
    main()
