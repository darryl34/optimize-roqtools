#! /usr/bin/env python
# *************************************************************************************
# Hpspice regulator model generator (UI backend)
# Script version: 1.0
# Python version: Python 3.6.5
# Compatible OS: Windows 10
# Requirements: Tkinter, pyperclip, Hpspice, lib_digital_ic(v1.0)
# Developer (v1.0): Corena Tong (listong)
# Notes:
#     This is a script provides backend compute functionality for the UI created by
#    'regulator_gui.py'.
#   Command: python3 regulator_gui.py
# Version doc:
#  * First version
# *************************************************************************************
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 7.4
#  in conjunction with Tcl version 8.6
#    Jun 14, 2022 08:46:23 AM CST  platform: Windows NT

import pyperclip as pc
import sys
import tkinter as tk
from tkinter import messagebox
import tkinter.ttk as ttk

import digital_ic_gui
import lib_digital_ic
import optimizeCML
import optimizeECL
import optimizeLVDS
from util import runCmd

# Global members
PIN_LIST = []
pin_count = 0

def main(*args):
    '''Main entry point for the application.'''
    global root
    root = tk.Tk()
    root.protocol( 'WM_DELETE_WINDOW' , root.destroy)
    # Creates a toplevel widget.
    global _w1
    _w1 = digital_ic_gui.Toplevel1(root)
    root.mainloop()

def copyBtnClicked(*args):
    print('digital_ic_support.copyBtnClicked')
    # Copy the content inside the result box, to be update
    pc.copy(_w1.Scrolledtext1.get("1.0", tk.END))
    sys.stdout.flush()


def createLvdsBtnClicked(*args):
    global _top2, _w2
    _top2 = tk.Toplevel(root)
    _w2 = digital_ic_gui.Toplevel2(_top2)


def submitLvdsBtnClicked(*args):
    print('digital_ic_support.submitLvdsBtnClicked')
    sys.stdout.flush()

    # Clear existing output
    clearScrollText()
    
    # Check if all required fields are filled
    lvds_params_filled = _w2.mpd1_L.get() and _w2.mpd1_H.get() \
                    and _w2.mnd1_L.get() and _w2.mnd1_H.get() \
                    and _w2.pKp_L.get() and _w2.pKp_H.get() \
                    and _w2.pRd_L.get() and _w2.pRd_H.get() \
                    and _w2.pRs_L.get() and _w2.pRs_H.get() \
                    and _w2.nKp_L.get() and _w2.nKp_H.get() \
                    and _w2.nRd_L.get() and _w2.nRd_H.get() \
                    and _w2.nRs_L.get() and _w2.nRs_H.get() \
                    and _w2.voh.get() and _w2.vol.get() \
                    
    if not checkReqFields() or not lvds_params_filled:
        messagebox.showerror("Input Error", "Please fill all the required fields.")
        return

    _top2.withdraw()

    kpn = _w1.kpn.get()
    
    # Generate model
    print("[INFO] Generating model ...", flush=True)
    reg_model = lib_digital_ic.main_gen_lvds_model(pin_list=PIN_LIST, inputType=_w1.inputInterfaceOption.get(),
                    pVCC=_w1.vccPinNum.get(), pGND=_w1.gndPinNum.get(), kpn=kpn)

    print("[INFO] Generating model ... done", flush=True)

    # write to file
    model_file = '{}.inc'.format(kpn)
    with open(model_file, 'w') as f:
        f.write(reg_model)


    # Generate harness
    print("[INFO] Generating harness ...", flush=True)
    reg_harness = lib_digital_ic.gen_lvds_harness(kpn=kpn, pin_list=PIN_LIST, vcc=_w1.vcc.get(), vPos=_w1.vin.get(), vNeg=_w1.vee.get())
    

    # Open harness.cki file and write reg_harness into ds.cki
    with open("fixture.cki", "w") as f:
        f.write(reg_harness)
    print("[INFO] Generating harness ... done", flush=True)
    

    # Generate core.cmd
    print("[INFO] Generating core.cmd..", flush=True)
    delta = str(round((float(_w2.voh.get()) - float(_w2.vol.get()))*1000))
    com = str(round((float(_w2.voh.get()) + float(_w2.vol.get())) / 2, 2))
    reg_core_cmd = lib_digital_ic.gen_lvds_cmd(_w2.voh.get(), _w2.vol.get(), delta, com)
    # create core.cmd and write reg_core_cmd into cmd
    with open("core.cmd", "w") as f:
        f.write(reg_core_cmd)
    print("[INFO] Generating core.cmd ... done", flush=True)
    
    # Perform optimization
    print("Optimizing parameters. Please wait...", flush=True)
    optimizeLVDS.run_with_params(model_file, float(_w2.mpd1_L.get()), float(_w2.mpd1_H.get()),
                                 float(_w2.mnd1_L.get()), float(_w2.mnd1_H.get()),
                                 float(_w2.pKp_L.get()), float(_w2.pKp_H.get()),
                                 float(_w2.pRd_L.get()), float(_w2.pRd_H.get()),
                                 float(_w2.pRs_L.get()), float(_w2.pRs_H.get()),
                                 float(_w2.nKp_L.get()), float(_w2.nKp_H.get()),
                                 float(_w2.nRd_L.get()), float(_w2.nRd_H.get()),
                                 float(_w2.nRs_L.get()), float(_w2.nRs_H.get()),
                                 float(_w2.voh.get()) ,float(_w2.vol.get()))
    
    print("[INFO] Performing optimization ... done", flush=True)
    
    # print to result box
    with open(model_file, 'r') as f:
        reg_model = f.read()

    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.insert(tk.INSERT, reg_model)
    _w1.Scrolledtext1.insert(tk.INSERT, "\n\n*******************************************************************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "********************END OF MODEL BEGIN HARNESS *********************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "*******************************************************************\n\n")
    _w1.Scrolledtext1.insert(tk.INSERT, reg_harness)
    _w1.Scrolledtext1.insert(tk.INSERT, "\n\n*******************************************************************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "********************END OF HARNESS BEGIN CMD *********************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "*******************************************************************\n\n")
    _w1.Scrolledtext1.insert(tk.INSERT, reg_core_cmd)
    _w1.Scrolledtext1.insert(tk.INSERT, "\n\n*******************************************************************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, str(runCmd()))
    _w1.Scrolledtext1.insert(tk.INSERT, "*******************************************************************\n\n")
    _w1.Scrolledtext1.configure(state='disabled')
    
    #print("[INFO] Generating stress.cmd ... done", flush=True)
    print("[INFO] LVDS modelling completed", flush=True)


def createEclBtnClicked(*args):
    global _top3, _w3
    _top3 = tk.Toplevel(root)
    _w3 = digital_ic_gui.Toplevel3(_top3)
    print(_w1.inputInterfaceOption.get())

def submitEclBtnClicked(*args):
    print('digital_ic_support.submitEclBtnClicked')
    sys.stdout.flush()

    # Clear existing output
    clearScrollText()

    # check if all required fields are filled
    ecl_params_filled = _w3.rb1_L.get() and _w3.rb1_H.get() \
                and _w3.rb1_L.get() and _w3.rb1_H.get() \
                and _w3.voh.get() and _w3.vol.get()

    if not checkReqFields() or not ecl_params_filled:
        messagebox.showerror("Input Error", "Please fill all the required fields.")
        return
    
    _top3.withdraw()
    kpn = _w1.kpn.get()

    # Generate model
    print("[INFO] Generating model ...", flush=True)
    
    # Generating model based on user's inputs
    reg_model = lib_digital_ic.main_gen_ecl_model(pin_list=PIN_LIST, inputType=_w1.inputInterfaceOption.get(), 
                                                  pVCC=_w1.vccPinNum.get(), pGND=_w1.gndPinNum.get(), kpn=kpn)

    print("[INFO] Generating model ... done", flush=True)

    # Create new .inc file
    model_file = "{}.inc".format(kpn)
    with open(model_file, "w") as f:
        f.write(reg_model)


    # Generate harness
    print("[INFO] Generating harness ...", flush=True)
    reg_harness, _ = lib_digital_ic.gen_ecl_harness(kpn=kpn, pin_list=PIN_LIST, vcc=_w1.vcc.get(), vin=_w1.vin.get(), vee=_w1.vee.get(), vtt=_w1.vtt.get())

    # Open fixture.cki file and write reg_harness into cki file
    with open("fixture.cki", "w") as f:
        f.write(reg_harness)
    print("[INFO] Generating harness ... done", flush=True)

    # Generate core.cmd
    print("[INFO] Generating core.cmd..", flush=True)
    delta = str(round((float(_w3.voh.get()) - float(_w3.vol.get()))*1000))
    com = str(round((float(_w3.voh.get()) + float(_w3.vol.get())) / 2, 2))
    reg_core_cmd = lib_digital_ic.gen_ecl_cmd(_w3.voh.get(), _w3.vol.get(), delta, com)
    # create core.cmd and write reg_core_cmd into cmd
    with open("core.cmd", "w") as f:
        f.write(reg_core_cmd)
    print("[INFO] Generating core.cmd ... done", flush=True)
    
    print("Optimizing parameters. Please wait...", flush=True)
    optimizeECL.run_with_params(model_file, int(_w3.rb1_L.get()), int(_w3.rb1_H.get()),
                int(_w3.rb2_L.get()), int(_w3.rb2_H.get()),
                float(_w3.voh.get()), float(_w3.vol.get()))
    
    with open(model_file, "r") as f:
        reg_model = f.read()

    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.insert(tk.INSERT, reg_model)
    _w1.Scrolledtext1.insert(tk.INSERT, "\n\n*******************************************************************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "********************END OF MODEL BEGIN HARNESS *********************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "*******************************************************************\n\n")
    _w1.Scrolledtext1.insert(tk.INSERT, reg_harness)
    _w1.Scrolledtext1.insert(tk.INSERT, "\n\n*******************************************************************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "********************END OF HARNESS BEGIN CMD *********************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "*******************************************************************\n\n")
    _w1.Scrolledtext1.insert(tk.INSERT, reg_core_cmd)
    _w1.Scrolledtext1.configure(state='disabled')

    #print("[INFO] Generating stress.cmd ... done", flush=True)
    print("[INFO] ECL modelling completed", flush=True)
    

def createCmlBtnClicked(*args):
    global _top4, _w4
    _top4 = tk.Toplevel(root)
    _w4 = digital_ic_gui.Toplevel4(_top4)

def submitCmlBtnClicked(*args):
    print('digital_ic_support.submitCmlBtnClicked')
    for arg in args:
        print ('another arg:', arg)
    sys.stdout.flush()

    # Clear existing output
    clearScrollText()

    cml_params_filled = _w4.rb1_L.get() and _w4.rb1_H.get() \
                        and _w4.rb2_L.get() and _w4.rb2_H.get() \
                        and _w4.rb3_L.get() and _w4.rb3_H.get() \
                        and _w4.rb4_L.get() and _w4.rb4_H.get() \
                        and _w4.voh.get() and _w4.vol.get()


    if not checkReqFields() or not cml_params_filled:
        messagebox.showerror("Input Error", "Please fill all the required fields.")
        return
    
    _top4.withdraw()

    kpn = _w1.kpn.get()

    # Generate model
    print("[INFO] Generating model ...", flush=True)
    reg_model = lib_digital_ic.main_gen_cml_model(pin_list=PIN_LIST, inputType=_w1.inputInterfaceOption.get(),
                                                  pVCC=_w1.vccPinNum.get(), pGND=_w1.gndPinNum.get(), kpn=kpn) 

    print("[INFO] Generating model ... done", flush=True)

    # Create new .inc file
    model_file = '{}.inc'.format(kpn)
    with open(model_file, 'w') as f:
        f.write(reg_model)


    # Generate harness
    print("[INFO] Generating harness ...", flush=True)
    reg_harness = lib_digital_ic.gen_cml_harness(kpn=kpn, pin_list=PIN_LIST, vcc=_w1.vcc.get(), vee=_w1.vee.get(), vin=_w1.vpos.get())
    

    # Open harness.cki file and write reg_harness into ds.cki
    with open("fixture.cki", "w") as f:
        f.write(reg_harness)
    print("[INFO] Generating harness ... done", flush=True)
    

    # Generate core.cmd
    print("[INFO] Generating core.cmd..", flush=True)
    delta = str(round((float(_w4.voh.get()) - float(_w4.vol.get()))*1000))
    com = str(round((float(_w4.voh.get()) + float(_w4.vol.get())) / 2, 2))
    reg_core_cmd = lib_digital_ic.gen_cml_cmd(_w4.voh.get(), _w4.vol.get(), delta, com)
    
    
    # create core.cmd and write reg_core_cmd into cmd
    with open("core.cmd", "w") as f:
        f.write(reg_core_cmd)
    print("[INFO] Generating core.cmd ... done", flush=True)
    
    print("Optimizing parameters. Please wait...", flush=True)
    optimizeCML.run_with_params(model_file, int(_w4.rb1_L.get()), int(_w4.rb1_H.get()),
                                int(_w4.rb2_L.get()), int(_w4.rb2_H.get()),
                                int(_w4.rb3_L.get()), int(_w4.rb3_H.get()),
                                int(_w4.rb4_L.get()), int(_w4.rb4_H.get()),
                                float(_w4.voh.get()), float(_w4.vol.get()))

    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.insert(tk.INSERT, reg_model)
    _w1.Scrolledtext1.insert(tk.INSERT, "\n\n*******************************************************************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "********************END OF MODEL BEGIN HARNESS *********************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "*******************************************************************\n\n")
    _w1.Scrolledtext1.insert(tk.INSERT, reg_harness)
    _w1.Scrolledtext1.insert(tk.INSERT, "\n\n*******************************************************************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "********************END OF HARNESS BEGIN CMD *********************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "*******************************************************************\n\n")
    _w1.Scrolledtext1.insert(tk.INSERT, reg_core_cmd)
    _w1.Scrolledtext1.configure(state='disabled')
    
    print("[INFO] CML modelling completed", flush=True)
    

def loadPinBtnClicked(*args):
    print('digital_ic_support.loadPinBtnClicked')
    '''
    Method to load pin information from textbox(UI).
    '''
    try:
        # Check if the list is filled or empty
        pininfo = _w1.pinInfoText.get("1.0","end-1c")
        if pininfo:
            global PIN_LIST, pin_count, search_list, ser_pin_list
            #pininfo = _w1.pinInfoText.get("1.0","end-1c")
            pininfo = pininfo.splitlines()
            pin = []
            for x in pininfo:
                temp = x.split()
                if temp[1].isnumeric() or "%" in temp[1]:
                    pin.append([temp[1],temp[2]])
                    pin_count += 1
            PIN_LIST[:] = list(pin)
            
            # Rename pins with same name
            pin_names=[item[1] for item in PIN_LIST]
            pin_nums=[item[0] for item in PIN_LIST]
            p_lst_dups = set()
            PIN_LIST = []
            for i in range(pin_count):
                count = pin_names.count(pin_names[i])
                if count > 1:
                    p_lst_dups.add(pin_names[i])
                    pin_names[i] = pin_names[i]+"_"+str(count)
                elif pin_names[i] in p_lst_dups:
                    pin_names[i] = pin_names[i]+"_1"
                PIN_LIST.append([pin_nums[i], pin_names[i]])
                pin_names[i] = ''
                pin_nums[i] = ''
            # PIN_LIST.reverse()

            search_list = PIN_LIST
            ser_pin_list = list(range(len(search_list)))
            updatePinList()
            clrList()
            _w1.pinNum.set('''Number of Pins : '''+str(pin_count)) 

            for pin in PIN_LIST:
                if not _w1.vccPinNum.get() and "vcc" in pin[1].lower():
                    _w1.vccPinNum.set(pin[0])
                elif not _w1.gndPinNum.get() and ("gnd" in pin[1].lower() or "vee" in pin[1].lower()):
                    _w1.gndPinNum.set(pin[0])
        else:
            messagebox.showerror("Input Error", "Either Input Pin Information is empty or first line in the box is empty.")
            
    except Exception as e:
        print("Error in assigning: ",e)

    sys.stdout.flush()
    pin_count = 0
            

def updatePinList():
    '''
    Method to load given list into Listbox.
    '''
    try:
        _w1.Listbox1.delete(0,'end')
        for i in range(len(PIN_LIST)):
            _w1.Listbox1.insert(i+1, ' '.join(PIN_LIST[i]))
    except Exception as e:
        print("Error in updating Listbox: ",e)

def clrList():
    '''
    Method to clear all selection in list.
    '''
    global sel_pin_list
    _w1.Listbox1.selection_clear(0, tk.END)
    sel_pin_list = []


def resetBtnClicked(*args):
    print('digital_ic_support.resetBtnClicked')
    clearPinInfo()
    clearScrollText()
    sys.stdout.flush()

def clearPinInfo():
    _w1.vccPinEntry.delete(0, tk.END)
    _w1.gndPinEntry.delete(0, tk.END)
    _w1.kpn.set('')
    _w1.vcc.set('')
    _w1.vpos.set('')
    _w1.vee.set('')
    _w1.vtt.set('')

def clearScrollText():
    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.delete("1.0", tk.END)
    _w1.Scrolledtext1.configure(state='disabled')

def checkReqFields():
    return _w1.vccPinNum.get() and _w1.gndPinNum.get() and _w1.kpn.get() and _w1.vcc.get()

if __name__ == '__main__':
    digital_ic_gui.start()
