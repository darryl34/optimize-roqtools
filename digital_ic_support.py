#! /usr/bin/env python
# *************************************************************************************
# Hpspice regulator model generator (UI backend)
# Script version: 1.0
# Python version: Python 3.6.5
# Compatible OS: Windows 10
# Requirements: Tkinter, pyperclip, Hpspice, lib_digital_ic(v1.0)
# Developer (v1.0): Corena Tong (listong)
# Notes:
#     This is a script provides backend compute functionality for the UI created by
#    'regulator_gui.py'.
#   Command: python3 regulator_gui.py
# Version doc:
#  * First version
# *************************************************************************************
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 7.4
#  in conjunction with Tcl version 8.6
#    Jun 14, 2022 08:46:23 AM CST  platform: Windows NT

import sys
import os
import re
import pyperclip as pc
import tkinter as tk
import tkinter.ttk as ttk
import subprocess
import digital_ic_gui
import lib_digital_ic

# Global members
PIN_LIST       = []
pin_count      = 0

def main(*args):
    '''Main entry point for the application.'''
    global root
    root = tk.Tk()
    root.protocol( 'WM_DELETE_WINDOW' , root.destroy)
    # Creates a toplevel widget.
    global _top1, _w1
    _top1 = root
    _w1 = digital_ic_gui.Toplevel1(_top1)
    root.mainloop()

def copyBtnClicked(*args):
    print('digital_ic_support.copyBtnClicked')
    for arg in args:
        print ('another arg:', arg)
    # Copy the content inside the result box, to be update
    pc.copy(_w1.Scrolledtext1.get("1.0", tk.END))
    sys.stdout.flush()

def createLvdsBtnClicked(*args):
    print('digital_ic_support.createLvdsBtnClicked')
    for arg in args:
        print ('another arg:', arg)
    sys.stdout.flush()

    # Clear existing output
    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.delete("1.0", tk.END)
    _w1.Scrolledtext1.configure(state='disabled')

    # Check for user's input on model settings and generate for harness and cmd
    global _top2, _w2
    _top2 = tk.Toplevel(root)
    _w2 = digital_ic_gui.Toplevel2(_top2)

def fillLvdsBtnClicked(*args):  
    print('digital_ic_support.fillLvdsBtnClicked')
    for arg in args:
        print ('another arg:', arg)
    sys.stdout.flush()

    _w2.rcss.set("39.22")
    _w2.rTermination.set("")
    _w2.lvdsDiodeVolt.set("0.5")
    _w2.lvdsDiodeCurr.set("10m")
    _w2.lvdsDiodeN.set("1")
    _w2.lvdsDiodeIS.set("37.5e-12")
    _w2.lvdsDiodeRS.set("1")
    _w2.lvdsMl2wp2aL.set("2u") 
    _w2.lvdsMl2wp2aW.set("15u")
    _w2.lvdsMp7pmodL.set("1u")
    _w2.lvdsMp7pmodW.set("300u")
    _w2.lvdsMp8pmodL.set("1u")
    _w2.lvdsMp8pmodW.set("300u")
    _w2.lvdsMn7nmodL.set("1u")
    _w2.lvdsMn7nmodW.set("200u")
    _w2.lvdsMn8nmodL.set("1u")
    _w2.lvdsMn8nmodW.set("200u")
    _w2.lvdsMl2wn2aL.set("2u")
    _w2.lvdsMl2wn2aW.set("15u")
    _w2.lvdsPmodPmosVto.set("0.7")
    _w2.lvdsPmodPmosKp.set("300u")
    _w2.lvdsPmodPmosRd.set("49")
    _w2.lvdsPmodPmosRs.set("49")
    _w2.lvdsNmodNmosVto.set("-0.7")
    _w2.lvdsNmodNmosKp.set("350u")
    _w2.lvdsNmodNmosRd.set("50")
    _w2.lvdsNmodNmosRs.set("50")
    _w2.lvdsMl2wn2aNmosVto.set("-0.5")
    _w2.lvdsMl2wn2aNmosKp.set("6.20m")
    _w2.lvdsMl2wn2aNmosRd.set("5m")
    _w2.lvdsMl2wn2aNmosRs.set("5m")
    _w2.lvdsMl2wp2aPmosVto.set("0.5")
    _w2.lvdsMl2wp2aPmosKp.set("6.20m")
    _w2.lvdsMl2wp2aPmosRd.set("5m")
    _w2.lvdsMl2wp2aPmosRs.set("5m")
                                                    
  
def submitLvdsBtnClicked(*args):
    print('digital_ic_support.submitLvdsBtnClicked')
    for arg in args:
        print ('another arg:', arg)
    sys.stdout.flush()

    # Generate model
    # Generate 1 ohm resistor network for similar pins
    shorts = lib_digital_ic.short_similar_pins(pin_list=PIN_LIST, resistance="1")
    # Generate model
    print("[INFO] Generating model ...", flush=True)
    reg_model = ""
    
    # Generating model based on user's inputs
    reg_model += lib_digital_ic.gen_lvds_model(pin_list=PIN_LIST, pGND=_w1.gndPinNum.get(), pVCC=_w1.vccPinNum.get(),
                    pVEE=_w1.veePinNum.get(), rcss=_w2.rcss.get(), rTermination=_w2.rTermination.get(), res_shorts=shorts, kpn=_w1.kpn.get())
    reg_model += lib_digital_ic.gen_lvds_clamp_diode(pin_list=PIN_LIST, pVCC=_w1.vccPinNum.get(), pGND=_w1.gndPinNum.get(), 
                    dVolt=_w2.lvdsDiodeVolt.get(), dCurr=_w2.lvdsDiodeCurr.get(), dN=_w2.lvdsDiodeN.get(), dIS=_w2.lvdsDiodeIS.get(), dRS=_w2.lvdsDiodeRS.get())
    reg_model += ".ends\n"
    reg_model += "*******************************************************************\n"
    reg_model += "********************** SUB-CIRCUIT ********************************\n"
    reg_model += "*******************************************************************\n"
    reg_model += "\n"
    reg_model += lib_digital_ic.gen_lvds_subckt(L_ml2wp2a=_w2.lvdsMl2wp2aL.get(), W_ml2wp2a=_w2.lvdsMl2wp2aW.get(),
                                                L_mp7pmod=_w2.lvdsMp7pmodL.get(), W_mp7pmod=_w2.lvdsMp7pmodW.get(),
                                                L_mp8pmod=_w2.lvdsMp8pmodL.get(), W_mp8pmod=_w2.lvdsMp8pmodW.get(),
                                                L_mn7nmod=_w2.lvdsMn7nmodL.get(), W_mn7nmod=_w2.lvdsMn7nmodW.get(),
                                                L_mn8nmod=_w2.lvdsMn8nmodL.get(), W_mn8nmod=_w2.lvdsMn8nmodW.get(),
                                                L_ml2wn2a=_w2.lvdsMl2wn2aL.get(), W_ml2wn2a=_w2.lvdsMl2wn2aW.get(),
                                                VTO_pmodPmos=_w2.lvdsPmodPmosVto.get(), KP_pmodPmos=_w2.lvdsPmodPmosKp.get(), RD_pmodPmos=_w2.lvdsPmodPmosRd.get(), RS_pmodPmos=_w2.lvdsPmodPmosRs.get(), 
                                                VTO_nmodNmos=_w2.lvdsNmodNmosVto.get(), KP_nmodNmos=_w2.lvdsNmodNmosKp.get(), RD_nmodNmos=_w2.lvdsNmodNmosRd.get(), RS_nmodNmos=_w2.lvdsNmodNmosRs.get(), 
                                                VTO_ml2wn2aNmos=_w2.lvdsMl2wn2aNmosVto.get(), KP_ml2wn2aNmos=_w2.lvdsMl2wn2aNmosKp.get(), RD_ml2wn2aNmos=_w2.lvdsMl2wn2aNmosRd.get(), RS_ml2wn2aNmos=_w2.lvdsMl2wn2aNmosRs.get(), 
                                                VTO_ml2wp2aPmos=_w2.lvdsMl2wp2aPmosVto.get(), KP_ml2wp2aPmos=_w2.lvdsMl2wp2aPmosKp.get(), RD_ml2wp2aPmos=_w2.lvdsMl2wp2aPmosRd.get(), RS_ml2wp2aPmos=_w2.lvdsMl2wp2aPmosRs.get(), 
                                                kpn=_w1.kpn.get())
                                                

    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.insert(tk.INSERT, reg_model)
    _w1.Scrolledtext1.configure(state='disabled')
    print("[INFO] Generating model ... done", flush=True)

    # Open kpn.inc file and write reg_model into kpn.inc
    if os.path.exists('{}.inc'.format(_w1.kpn.get())):  
        print("File exist\n")
        model_config = ""
        config_written = False 
        #inserting header and ratings section into model template file
        with open('{}.inc'.format(_w1.kpn.get()), 'r+') as f: #r+ does the work of rw
            lines = f.readlines()
            if len(lines)>0 and lines[0].startswith('* Start of model for '):
                for i, line in enumerate(lines):
                    if line.startswith('* Model for '):
                        # empty or remove the line
                        model_config += ""                        
                    elif line.startswith('*'):
                        model_config += lines[i]
                    else:
                        if not config_written: 
                            model_config += reg_model
                            config_written = True
                        else: 
                            # empty or remove the line
                            model_config += ""
                
                f.seek(0) #back to first line in the file
                f.truncate(0) # clear all text in the file, need '0' when using r+
                for line in model_config:
                    f.write(line)
            else:
                print("No lines found\n")
        
    else: 
        #print("Create a new file\n")
        wf = open('{}.inc'.format(_w1.kpn.get()), "w")
        wf.write(reg_model)
        wf.close()

    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.insert(tk.INSERT, "\n\n*******************************************************************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "********************END OF MODEL BEGIN HARNESS *********************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "*******************************************************************\n\n")
    _w1.Scrolledtext1.configure(state='disabled')

    # Generate harness
    print("[INFO] Generating harness ...", flush=True)
    reg_harness = ""
    reg_harness = lib_digital_ic.gen_lvds_harness(kpn=_w1.kpn.get(), pin_list=PIN_LIST, vcc=_w1.vcc.get(), vPos=_w1.vpos.get(), vNeg=_w1.vneg.get())
    
    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.insert(tk.INSERT, reg_harness)
    _w1.Scrolledtext1.configure(state='disabled')

    # Open harness.cki file and write reg_harness into ds.cki
    wf = open("fixture.cki", "w")
    wf.write(reg_harness)
    wf.close()
    print("[INFO] Generating harness ... done", flush=True)
    
    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.insert(tk.INSERT, "\n\n*******************************************************************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "********************END OF HARNESS BEGIN CMD *********************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "*******************************************************************\n\n")
    _w1.Scrolledtext1.configure(state='disabled')

    # Generate core.cmd
    print("[INFO] Generating core.cmd..", flush=True)
    reg_core_cmd = ""
    reg_core_cmd = lib_digital_ic.gen_lvds_cmd()
    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.insert(tk.INSERT, reg_core_cmd)
    _w1.Scrolledtext1.configure(state='disabled')
    # create core.cmd and write reg_core_cmd into cmd
    wf = open("core.cmd", "w")
    wf.write(reg_core_cmd)
    wf.close()
    print("[INFO] Generating core.cmd ... done", flush=True)
    
    # Execute . cmd_ds
    subprocess.call(["hpspice","-s","-c","'.","core.cmd'"])
    
    #print("[INFO] Generating stress.cmd ... done", flush=True)
    print("[INFO] LVDS modelling completed", flush=True)
    
    # Close second window
    _top2.withdraw() 

def createEclBtnClicked(*args):
    print('digital_ic_support.createEclBtnClicked')
    for arg in args:
        print ('another arg:', arg)
    sys.stdout.flush()

    # Clear existing output
    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.delete("1.0", tk.END)
    _w1.Scrolledtext1.configure(state='disabled')

    # Check for user's input on model settings and generate for harness and cmd
    global _top3, _w3
    _top3 = tk.Toplevel(root)
    _w3 = digital_ic_gui.Toplevel3(_top3)

def fillEclBtnClicked(*args):  
    print('digital_ic_support.fillEclBtnClicked')
    for arg in args:
        print ('another arg:', arg)
    sys.stdout.flush()

    _w3.eclMl2wn2aL.set("2u")
    _w3.eclMl2wn2aW.set("78u")
    _w3.rVee.set("75K")
    _w3.rVcc.set("37k")
    _w3.rB1.set("195")
    _w3.rB2.set("125")
    _w3.mb1_L.set("2u")
    _w3.mb1_W.set("60u")
    _w3.mb2_L.set("2u")
    _w3.mb2_W.set("10u")

def submitEclBtnClicked(*args):
    print('digital_ic_support.submitEclBtnClicked')
    for arg in args:
        print ('another arg:', arg)
    sys.stdout.flush()

    # Generate model
    # Generate 1 ohm resistor network for similar pins
    shorts = lib_digital_ic.short_similar_pins(pin_list=PIN_LIST, resistance="1")
    # Generate model
    print("[INFO] Generating model ...", flush=True)
    reg_model = ""
    
    # Generating model based on user's inputs
    reg_model += lib_digital_ic.gen_ecl_model(pin_list=PIN_LIST, pGND=_w1.gndPinNum.get(), pVCC=_w1.vccPinNum.get(), pVEE=_w1.veePinNum.get(), 
                                                res_shorts=shorts,kpn=_w1.kpn.get()) 
    reg_model += lib_digital_ic.gen_ecl_mcl(pVCC=_w1.vccPinNum.get(),  pGND=_w1.gndPinNum.get(), pVEE=_w1.veePinNum.get(), 
                                                L_ml2wn2a=_w3.eclMl2wn2aL.get(), W_ml2wn2a=_w3.eclMl2wn2aW.get())
    reg_model += ".ends\n"
    reg_model += lib_digital_ic.gen_ecl_inp_subckt(pGND=_w1.gndPinNum.get(), pVEE=_w1.veePinNum.get(), rVEE=_w3.rVee.get(), rVCC=_w3.rVcc.get(), kpn=_w1.kpn.get())
    reg_model += lib_digital_ic.gen_ecl_outp_subckt(rB1=_w3.rB1.get(), rB2=_w3.rB2.get(), 
                                                    mb1_L=_w3.mb1_L.get(), mb1_W=_w3.mb1_W.get(), mb2_L=_w3.mb2_L.get(), mb2_W=_w3.mb2_W.get(), kpn=_w1.kpn.get())                                            
    reg_model += "*******************************************************************\n"
    reg_model += "********************** SUB-CIRCUIT ********************************\n"
    reg_model += "*******************************************************************\n"
    reg_model += "\n"

    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.insert(tk.INSERT, reg_model)
    _w1.Scrolledtext1.configure(state='disabled')
    print("[INFO] Generating model ... done", flush=True)

    # Open kpn.inc file and write reg_model into kpn.inc
    if os.path.exists('{}.inc'.format(_w1.kpn.get())):  
        print("File exist\n")
        model_config = ""
        config_written = False 
        #inserting header and ratings section into model template file
        with open('{}.inc'.format(_w1.kpn.get()), 'r+') as f: #r+ does the work of rw
            lines = f.readlines()
            if len(lines)>0 and lines[0].startswith('* Start of model for '):
                for i, line in enumerate(lines):
                    if line.startswith('* Model for '):
                        # empty or remove the line
                        model_config += ""                        
                    elif line.startswith('*'):
                        model_config += lines[i]
                    else:
                        if not config_written: 
                            model_config += reg_model
                            config_written = True
                        else: 
                            # empty or remove the line
                            model_config += ""
                
                f.seek(0) #back to first line in the file
                f.truncate(0) # clear all text in the file, need '0' when using r+
                for line in model_config:
                    f.write(line)
            else:
                print("No lines found\n")
        
    else: 
        #print("Create a new file\n")
        wf = open('{}.inc'.format(_w1.kpn.get()), "w")
        wf.write(reg_model)
        wf.close()

    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.insert(tk.INSERT, "\n\n*******************************************************************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "********************END OF MODEL BEGIN HARNESS *********************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "*******************************************************************\n\n")
    _w1.Scrolledtext1.configure(state='disabled')

    # Generate harness
    print("[INFO] Generating harness ...", flush=True)
    reg_harness = ""
    reg_harness, numQ = lib_digital_ic.gen_ecl_harness(kpn=_w1.kpn.get(), pin_list=PIN_LIST, vcc=_w1.vcc.get(), vee=_w1.vee.get(), vtt=_w1.vtt.get())
    
    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.insert(tk.INSERT, reg_harness)
    _w1.Scrolledtext1.configure(state='disabled')

    # Open harness.cki file and write reg_harness into ds.cki
    wf = open("fixture.cki", "w")
    wf.write(reg_harness)
    wf.close()
    print("[INFO] Generating harness ... done", flush=True)
    
    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.insert(tk.INSERT, "\n\n*******************************************************************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "********************END OF HARNESS BEGIN CMD *********************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "*******************************************************************\n\n")
    _w1.Scrolledtext1.configure(state='disabled')

    # Generate core.cmd
    print("[INFO] Generating core.cmd..", flush=True)
    reg_core_cmd = ""
    reg_core_cmd = lib_digital_ic.gen_ecl_cmd(numQ)
    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.insert(tk.INSERT, reg_core_cmd)
    _w1.Scrolledtext1.configure(state='disabled')
    # create core.cmd and write reg_core_cmd into cmd
    wf = open("core.cmd", "w")
    wf.write(reg_core_cmd)
    wf.close()
    print("[INFO] Generating core.cmd ... done", flush=True)
    
    # Execute . core.cmd
    subprocess.call(["hpspice","-s","-c","'.","core.cmd'"])

    #print("[INFO] Generating stress.cmd ... done", flush=True)
    print("[INFO] ECL modelling completed", flush=True)
    
    # Close second window
    _top3.withdraw() 

def createCmlBtnClicked(*args):
    print('digital_ic_support.createCmlBtnClicked')
    for arg in args:
        print ('another arg:', arg)
    sys.stdout.flush()

    # Clear existing output
    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.delete("1.0", tk.END)
    _w1.Scrolledtext1.configure(state='disabled')

    # Check for user's input on model settings and generate for harness and cmd
    global _top4, _w4
    _top4 = tk.Toplevel(root)
    _w4 = digital_ic_gui.Toplevel4(_top4)

def fillCmlBtnClicked(*args):  
    print('digital_ic_support.fillEclBtnClicked')
    for arg in args:
        print ('another arg:', arg)
    sys.stdout.flush()

    _w4.rPD.set("38")
    _w4.rPDCurrent.set("90m")
    _w4.rPDVoltage.set("2.5")
    _w4.dVoltage.set("0.5")
    _w4.dCurrent.set("40m")
    _w4.dN.set("1")
    _w4.dIS.set("33n")
    _w4.dRS.set("3.5")

def submitCmlBtnClicked(*args):
    print('digital_ic_support.submitCmlBtnClicked')
    for arg in args:
        print ('another arg:', arg)
    sys.stdout.flush()

    # Generate model
    # Generate 1 ohm resistor network for similar pins
    shorts = lib_digital_ic.short_similar_pins(pin_list=PIN_LIST, resistance="1")
    # Generate model
    print("[INFO] Generating model ...", flush=True)
    reg_model = ""
    
    # Generating model based on user's inputs
    reg_model += lib_digital_ic.gen_cml_model(pin_list=PIN_LIST, pGND=_w1.gndPinNum.get(), pVCC=_w1.vccPinNum.get(), pVEE=_w1.veePinNum.get(), 
                                                current=_w4.rPDCurrent.get(), voltage=_w4.rPDVoltage.get(), rPD=_w4.rPD.get(), res_shorts=shorts,kpn=_w1.kpn.get()) 
    reg_model += ".ends\n"
    reg_model += lib_digital_ic.gen_cml_subckt(dVolt=_w4.dVoltage.get(), dCurrent=_w4.dCurrent.get(), dN=_w4.dN.get(), dIS=_w4.dIS.get(), dRS=_w4.dRS.get(), 
                                                kpn=_w1.kpn.get())
                                                
    reg_model += "*******************************************************************\n"
    reg_model += "********************** SUB-CIRCUIT ********************************\n"
    reg_model += "*******************************************************************\n"
    reg_model += "\n"

    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.insert(tk.INSERT, reg_model)
    _w1.Scrolledtext1.configure(state='disabled')
    print("[INFO] Generating model ... done", flush=True)

    # Open kpn.inc file and write reg_model into kpn.inc
    if os.path.exists('{}.inc'.format(_w1.kpn.get())):  
        print("File exist\n")
        model_config = ""
        config_written = False 
        #inserting header and ratings section into model template file
        with open('{}.inc'.format(_w1.kpn.get()), 'r+') as f: #r+ does the work of rw
            lines = f.readlines()
            if len(lines)>0 and lines[0].startswith('* Start of model for '):
                for i, line in enumerate(lines):
                    if line.startswith('* Model for '):
                        # empty or remove the line
                        model_config += ""                        
                    elif line.startswith('*'):
                        model_config += lines[i]
                    else:
                        if not config_written: 
                            model_config += reg_model
                            config_written = True
                        else: 
                            # empty or remove the line
                            model_config += ""
                
                f.seek(0) #back to first line in the file
                f.truncate(0) # clear all text in the file, need '0' when using r+
                for line in model_config:
                    f.write(line)
            else:
                print("No lines found\n")
        
    else: 
        #print("Create a new file\n")
        wf = open('{}.inc'.format(_w1.kpn.get()), "w")
        wf.write(reg_model)
        wf.close()

    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.insert(tk.INSERT, "\n\n*******************************************************************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "********************END OF MODEL BEGIN HARNESS *********************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "*******************************************************************\n\n")
    _w1.Scrolledtext1.configure(state='disabled')

    # Generate harness
    print("[INFO] Generating harness ...", flush=True)
    reg_harness = ""
    reg_harness = lib_digital_ic.gen_cml_harness(kpn=_w1.kpn.get(), pin_list=PIN_LIST, vcc=_w1.vcc.get(), vee=_w1.vee.get(), vin=_w1.vpos.get())
    
    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.insert(tk.INSERT, reg_harness)
    _w1.Scrolledtext1.configure(state='disabled')

    # Open harness.cki file and write reg_harness into ds.cki
    wf = open("fixture.cki", "w")
    wf.write(reg_harness)
    wf.close()
    print("[INFO] Generating harness ... done", flush=True)
    
    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.insert(tk.INSERT, "\n\n*******************************************************************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "********************END OF HARNESS BEGIN CMD *********************\n")
    _w1.Scrolledtext1.insert(tk.INSERT, "*******************************************************************\n\n")
    _w1.Scrolledtext1.configure(state='disabled')

    # Generate core.cmd
    print("[INFO] Generating core.cmd..", flush=True)
    reg_core_cmd = ""
    reg_core_cmd = lib_digital_ic.gen_cml_cmd()
    
    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.insert(tk.INSERT, reg_core_cmd)
    _w1.Scrolledtext1.configure(state='disabled')
    
    # create core.cmd and write reg_core_cmd into cmd
    wf = open("core.cmd", "w")
    wf.write(reg_core_cmd)
    wf.close()
    print("[INFO] Generating core.cmd ... done", flush=True)
    
    # Execute . core.cmd
    subprocess.call(["hpspice","-s","-c","'.","core.cmd'"])

    #print("[INFO] Generating cmd_eff ... done", flush=True)
    print("[INFO] CML modelling completed", flush=True)
    
    # Close second window
    _top4.withdraw() 


def loadPinBtnClicked(*args):
    print('digital_ic_support.loadPinBtnClicked')
    '''
    Method to load pin information from textbox(UI).
    '''
    try:
        # Check if the list is filled or empty
        pininfo = _w1.pinInfoText.get("1.0","end-1c")
        if pininfo:
            global PIN_LIST, pin_count, search_list, ser_pin_list
            #pininfo = _w1.pinInfoText.get("1.0","end-1c")
            pininfo = pininfo.split('\n')
            pin = []
            for x in pininfo:
                temp = x.split()
                if temp[1].isnumeric() or "%" in temp[1]:
                    pin.append([temp[1],temp[2]])
                    pin_count = pin_count + 1
            PIN_LIST[:] = list(pin)
            
            # Rename pins with same name
            pin_names=[item[1] for item in PIN_LIST]
            pin_numbs=[item[0] for item in PIN_LIST]
            p_lst_dups = set()
            PIN_LIST = []
            for i in range(0, pin_count):
                count = pin_names.count(pin_names[i])
                if count > 1:
                    p_lst_dups.add(pin_names[i])
                    pin_names[i] = pin_names[i]+"_"+str(count)
                elif pin_names[i] in p_lst_dups:
                    pin_names[i] = pin_names[i]+"_1"
                PIN_LIST.append([pin_numbs[i], pin_names[i]])
                pin_names[i] = ''
                pin_numbs[i] = ''
            # PIN_LIST.reverse()

            search_list = PIN_LIST
            ser_pin_list = list(range(0,len(search_list)))
            updatePinList()
            clrList()
            _w1.pinNum.set('''Number of Pins : '''+str(pin_count)) 

            # Attempt to auto detect pins
            # Reset entry boxes
            _w1.gndPinNum.set("")
            _w1.vccPinNum.set("")
            _w1.veePinNum.set("")
            _w1.vbbPinNum.set("")
            _w1.inselPinNum.set("")
            _w1.refPinNum.set("")
            _w1.vtrPinNum.set("")
            for pin_index in range(len(PIN_LIST)):
                if not _w1.vccPinNum.get() and "vcc" in PIN_LIST[pin_index][1].lower():
                    _w1.vccPinNum.set(PIN_LIST[pin_index][0])
                elif not _w1.gndPinNum.get() and "gnd" in PIN_LIST[pin_index][1].lower():
                    _w1.gndPinNum.set(PIN_LIST[pin_index][0])
                elif not _w1.veePinNum.get() and "vee" in PIN_LIST[pin_index][1].lower():
                    _w1.veePinNum.set(PIN_LIST[pin_index][0])
                elif not _w1.inselPinNum.get() and "in_sel" in PIN_LIST[pin_index][1].lower():
                    _w1.inselPinNum.set(PIN_LIST[pin_index][0])
                elif not _w1.refPinNum.get() and "ref" in PIN_LIST[pin_index][1].lower():
                    _w1.refPinNum.set(PIN_LIST[pin_index][0])
                elif not _w1.vbbPinNum.get() and "vbb" in PIN_LIST[pin_index][1].lower():
                    _w1.vbbPinNum.set(PIN_LIST[pin_index][0])
                elif not _w1.vtrPinNum.get() and "vt" in PIN_LIST[pin_index][1].lower():
                    _w1.vtrPinNum.set(PIN_LIST[pin_index][0])

            #reset pin_index numbering
            pin_index = 0
        else:
            tk.messagebox.showerror("Input Error", "Either Input Pin Information is empty or first line in the box is empty.")
            
    except Exception as e:
        print("Error in assigning: ",e)

    sys.stdout.flush()
    pin_count = 0
            

def updatePinList():
    '''
    Method to load given list into Listbox.
    '''
    try:
        _w1.Listbox1.delete(0,'end')
        for i in range(len(PIN_LIST)):
            _w1.Listbox1.insert(i+1, ' '.join(PIN_LIST[i]))
    except Exception as e:
        print("Error in updating Listbox: ",e)

def clrList():
    '''
    Method to clear all selection in list.
    '''
    global sel_pin_list
    _w1.Listbox1.selection_clear(0, tk.END)
    sel_pin_list = []

def resetBtnClicked(*args):
    print('digital_ic_support.resetBtnClicked')
    for arg in args:
        print ('another arg:', arg)
    _w1.vccPinEntry.delete(0, tk.END)
    _w1.gndPinEntry.delete(0, tk.END)
    _w1.veePinEntry.delete(0, tk.END)
    _w1.vbbPinEntry.delete(0, tk.END)
    _w1.inselPinEntry.delete(0, tk.END)
    _w1.refPinEntry.delete(0, tk.END)
    _w1.vtrPinEntry.delete(0, tk.END)
    _w1.kpn.delete(0, tk.END)
    _w1.vcc.delete(0, tk.END)
    _w1.vpos.delete(0, tk.END)
    _w1.vneg.delete(0, tk.END)
    _w1.vee.delete(0, tk.END)
    _w1.vtt.delete(0, tk.END)
    _w1.Scrolledtext1.configure(state='normal')
    _w1.Scrolledtext1.delete("1.0", tk.END)
    _w1.Scrolledtext1.configure(state='disabled')

    sys.stdout.flush()

def exitLvdsBtnClicked(*args):
    print('digital_ic_support.submitLvdsBtnClicked')
    for arg in args:
        print ('another arg:', arg)
    sys.stdout.flush()
    _top2.withdraw() 

def exitEclBtnClicked(*args):
    print('digital_ic_support.submitEclBtnClicked')
    for arg in args:
        print ('another arg:', arg)
    sys.stdout.flush()
    _top3.withdraw() 

def exitCmlBtnClicked(*args):
    print('digital_ic_support.submitCmlBtnClicked')
    for arg in args:
        print ('another arg:', arg)
    sys.stdout.flush()
    _top4.withdraw() 

if __name__ == '__main__':
    digital_ic_gui.start_up()
